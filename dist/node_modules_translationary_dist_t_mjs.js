"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkplan_a"] = self["webpackChunkplan_a"] || []).push([["node_modules_translationary_dist_t_mjs"],{

/***/ "./node_modules/translationary/dist/t.mjs":
/*!************************************************!*\
  !*** ./node_modules/translationary/dist/t.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Translationary)\n/* harmony export */ });\nconst variableRegex = /(?:{{(.+?)}})/g;\nconst recursiveRegex = /(?:\\$t\\((.+?)\\))/g;\nconst Translationary = function Translationary(props) {\n    const { appName, lang, onLanguageChange, formatter, fetchTranslations } = props;\n    /** .\n     * Main translation function. Also defers to test when applicable.\n     *\n     * @param rawKey string\n     * @param rawOptions TranslationOptions | string\n     * @returns string\n     */\n    const translate = (rawKey, rawOptions = {}) => {\n        let options = rawOptions;\n        if (typeof rawOptions === \"string\") {\n            options = { defaultValue: rawOptions };\n        }\n        const { count, context, defaultValue, plural } = options;\n        let key = rawKey;\n        key = context ? `${key}_${context}` : key;\n        key =\n            plural || (typeof count === \"number\" && count > 1)\n                ? `${key}_plural`\n                : key;\n        let translation = key\n            .split(\".\")\n            .reduce((tr, k) => (tr === null || tr === void 0 ? void 0 : tr[k]) || defaultValue, this.translations);\n        if (this.testEnabled && !translation) {\n            throw new Error(`[ERR] translation ${key} is missing in ${this.lang} ${this.appName}`);\n        }\n        // this is separated so test mode has a chance to throw an error\n        translation = (translation || key);\n        /**\n         * this grabs variable calls from inside the strings and replaces\n         * them with the variable value. if no match is found, the variable is\n         * not replaced\n         *\n         * in test mode a missing variable throws an error. outside test it will\n         * return thge defaultValue on error (if available), or the key\n         */\n        let variableError = false;\n        (translation.match(variableRegex) || []).forEach((match) => {\n            const [variableString, format] = match.slice(2, -2).split(\", \");\n            const variable = variableString\n                .split(\".\")\n                .reduce((opt, v) => opt[v], options);\n            if (variable) {\n                translation = translation.replace(match, this.formatter(variable, format));\n            }\n            else if (this.testEnabled) {\n                throw new Error(`[ERR] translation ${key} is missing variable ${variableString}`);\n            }\n            else {\n                variableError = true;\n            }\n        });\n        if (variableError) {\n            return defaultValue || key;\n        }\n        (translation.match(recursiveRegex) || []).forEach((match) => {\n            const args = match.slice(3, -1).split(\", \");\n            const opt = args[1] ? JSON.parse(args.slice(1).join(\", \")) : undefined;\n            const translationKey = translate(args[0], opt);\n            translation = translation.replace(match, translationKey);\n        });\n        return translation;\n    };\n    /**\n     * Gets the current language.\n     */\n    this.getLanguage = () => {\n        return this.lang;\n    };\n    /**\n     * Gets the full translations object. Only works when test mode is enabled\n     * It is intended for testing as well as generating types.\n     */\n    this.getTranslations = () => {\n        if (this.testEnabled) {\n            return this.translations;\n        }\n        console.error(\"[ERR] getTranslations only works when test mode is enabled\");\n        return null;\n    };\n    /** .\n     * Handles setup of the variables and the retrieves initial translations\n     *\n     * @param appName string\n     * @param lang string\n     * @param onLanguageChange (lang) => void\n     * @param formatter\n     */\n    this.init = (app, language, formatterFunction, onLanguageChangeFunction) => {\n        this.appName = app;\n        this.lang = language;\n        this.formatter = formatterFunction;\n        this.onLanguageChange = onLanguageChangeFunction;\n        return this.setTranslations(lang);\n    };\n    /** .\n     * Sets the language internally, grabs the translations,\n     * then fires the onLanguageChange\n     *\n     * @param lang\n     */\n    this.setLanguage = (newLanguage) => {\n        this.lang = newLanguage;\n        return this.setTranslations(newLanguage);\n    };\n    /** .\n     * Enables or disables test mode\n     *\n     * @param test boolean\n     */\n    this.setTest = (test = true) => {\n        this.testEnabled = test;\n    };\n    /** .\n     * Grabs the translations from s3\n     *\n     * @param lang\n     * @returns Promise<translations>\n     */\n    this.setTranslations = (newLanguage) => {\n        const setTranslation = (translations) => {\n            this.translations = translations;\n        };\n        return new Promise((resolve) => {\n            resolve(fetchTranslations({\n                appName,\n                lang: newLanguage\n            }));\n        })\n            .then((res) => setTranslation(res))\n            .then(() => { var _a; return (_a = this.onLanguageChange) === null || _a === void 0 ? void 0 : _a.call(this, newLanguage); });\n    };\n    this.init(appName, lang, formatter, onLanguageChange);\n    return Object.assign(translate, {\n        getLanguage: this.getLanguage,\n        getTranslations: this.getTranslations,\n        setLanguage: this.setLanguage,\n        setTest: this.setTest\n    });\n};\n\n\n\n\n//# sourceURL=webpack://plan-a/./node_modules/translationary/dist/t.mjs?");

/***/ })

}]);